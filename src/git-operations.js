const fs = require('fs').promises;
const { execSync } = require('child_process');

async function commitFiles(files, message, options = {}) {
  const { 
    dryRun = false,
    addAll = false 
  } = options;

  if (files.length === 0 && !addAll) {
    console.log('üìù No files to commit');
    return false;
  }

  if (dryRun) {
    console.log(`üîç DRY RUN: Would commit ${files.length} files with message: ${message}`);
    return true;
  }

  try {
    if (addAll) {
      execSync('git add .');
      console.log('üìù Added all files to git');
    } else {
      // Add files to git
      for (const file of files) {
        execSync(`git add "${file}"`);
      }
      console.log(`üìù Added ${files.length} files to git`);
    }

    // Write commit message to file to handle special characters and newlines
    await fs.writeFile('.git_commit_msg', message);
    execSync('git commit -F .git_commit_msg');
    await fs.unlink('.git_commit_msg');
    
    console.log(`‚úÖ Committed ${addAll ? 'all changes' : `${files.length} files`}`);
    return true;
  } catch (error) {
    console.log(`‚ö†Ô∏è Commit failed: ${error.message}`);
    return false;
  }
}

function getCurrentBranch() {
  try {
    return execSync('git branch --show-current', { encoding: 'utf8' }).trim();
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not get current branch:', error.message);
    return 'main';
  }
}

function getGitStatus() {
  try {
    return execSync('git status --porcelain', { encoding: 'utf8' });
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not get git status:', error.message);
    return '';
  }
}

function createBranch(branchName, options = {}) {
  const { baseBranch = 'main', switchToBranch = true } = options;

  try {
    // Check if branch already exists
    try {
      execSync(`git rev-parse --verify ${branchName}`, { stdio: 'ignore' });
      console.log(`üåø Branch '${branchName}' already exists`);
      if (switchToBranch) {
        execSync(`git checkout ${branchName}`);
        console.log(`üåø Switched to branch '${branchName}'`);
      }
      return true;
    } catch (error) {
      // Branch doesn't exist, create it
    }

    // Ensure we're on the base branch
    execSync(`git checkout ${baseBranch}`);
    
    // Create and switch to new branch
    execSync(`git checkout -b ${branchName}`);
    console.log(`üåø Created and switched to branch '${branchName}'`);
    return true;
  } catch (error) {
    console.error(`‚ùå Failed to create branch '${branchName}':`, error.message);
    return false;
  }
}

async function pushAndCreatePR(branchName, title, issueContext, options = {}) {
  const { 
    baseBranch = 'main',
    createPR = true,
    pushFirst = true,
    dryRun = false
  } = options;

  if (dryRun) {
    console.log(`üîç DRY RUN: Would push branch '${branchName}' and create PR: ${title}`);
    return true;
  }

  try {
    if (pushFirst) {
      // Push the branch to remote
      console.log(`üöÄ Pushing branch '${branchName}' to remote...`);
      execSync(`git push -u origin ${branchName}`);
      console.log(`‚úÖ Pushed branch '${branchName}'`);
    }

    if (createPR) {
      // Create pull request (placeholder - implement with gh CLI or GitHub API)
      console.log(`üîÑ Creating pull request: ${title}`);
      
      // Try to use gh CLI if available
      try {
        const body = issueContext.description || issueContext.body || 'Automated code generation';
        const issueRef = issueContext.number ? `\n\nCloses #${issueContext.number}` : '';
        const prBody = `${body}${issueRef}\n\nü§ñ Generated by Berrry Committer`;
        
        execSync(`gh pr create --title "${title}" --body "${prBody}" --base ${baseBranch}`, { stdio: 'inherit' });
        console.log(`‚úÖ Pull request created successfully`);
      } catch (error) {
        console.log(`‚ö†Ô∏è Could not create PR with gh CLI: ${error.message}`);
        console.log(`üìù Please create PR manually:`);
        console.log(`   Title: ${title}`);
        console.log(`   Branch: ${branchName} -> ${baseBranch}`);
        if (issueContext.number) {
          console.log(`   Closes: #${issueContext.number}`);
        }
      }
    }

    return true;
  } catch (error) {
    console.error(`‚ùå Failed to push/create PR:`, error.message);
    return false;
  }
}

function normalizeForBranch(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '') // Remove special chars except spaces and hyphens
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single
    .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
    .substring(0, 50); // Limit length
}

function generateBranchName(issueContext) {
  const prefix = 'ai';
  const title = issueContext.title || 'untitled';
  const normalized = normalizeForBranch(title);
  const issueNumber = issueContext.number ? `-${issueContext.number}` : '';
  
  return `${prefix}/${normalized}${issueNumber}`;
}

module.exports = {
  commitFiles,
  getCurrentBranch,
  getGitStatus,
  createBranch,
  pushAndCreatePR,
  normalizeForBranch,
  generateBranchName
};